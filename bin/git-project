#!/usr/bin/env perl
use strict;

## increment this one when wire protocol *or* hooks change:
## NOTE: be sure to increment the build-pkg config to have the same
our $VERSION = 33;
## set this one to $VERSION only when the hooks change:
our $VERSION_HOOKS_COMPAT = 31;

our $CONFIGNAME = "gitproject.version";    # where we store $VERSION on update

use lib $ENV{GITPERLLIB}
    ? split( /:/, $ENV{GITPERLLIB} )
    : do {
    chomp( my $exec_path = qx{git --exec-path} );
    open my $gitsvn, "<", "$exec_path/git-svn" or die "Cannot find git-svn";
    {
        last unless defined( local $_ = readline $gitsvn );
        redo unless m{\Ause lib.*GITPERLLIB.*\|\| "(.*)"};
        "$1";
    }
    };

use Git;

sub Dump {
    my $tiny = YAML::Tiny->new;
    @$tiny = @_;
    return $tiny->write_string;
}

use Getopt::Long qw(GetOptions);
use Pod::Usage qw(pod2usage);

my @ITEM_GROUPS = qw(test
    apps-vendor
    apps
    os-images
    perl-libs-vendor
    perl-libs
    puppet-mods-base
    puppet-mods-deploy
    puppet-mods-site
    ruby-libs-vendor
    ruby-libs
    schemata
    vz-templates
    python
    python-vendor
);
my $MATCH_TYPE = join "|", @ITEM_GROUPS;
$MATCH_TYPE = qr{($MATCH_TYPE)};

my $VERSION_CHECK_DEFER = "$ENV{HOME}/.git-project-version-check.$<";
my $VERSION_CHECK_DEFER_INTERVAL = 60 * 60 * 24;    # once a day, in seconds

my $PREFIX;                                         # set in run(), but viewed everywhere
my $HOST;                                           # ditto

my $PROJECT_NAME = qr<\A(?!(master|trunk)\z)(?!\A-)(?!.*-\z)[-\w]{5,100}\z>i;

my $maybe_noisy = "command";

run(@ARGV) unless defined caller;

sub run {
    _usage() if @_ and $_[0] =~ m{\A-?(h(elp)?|man)\z};

    my $githost = $ENV{TEST_GIT_HOST} || q{git@git.mtsvc.net};
    if ( $githost =~ m{\A(/.*?)/?\z} ) {
        $HOST   = "CANNOT_RUN_COMMANDS_REMOTELY_WITHOUT_A_REMOTE";
        $PREFIX = "$1/";
    }
    else {
        $HOST   = $githost;
        $PREFIX = "$githost:";
    }

    ## permit -v on either side
    shift, $maybe_noisy = "command_noisy" if @_ and $_[0] eq "-v";
    my $command = shift or _usage("missing SUBCOMMAND");
    shift, $maybe_noisy = "command_noisy" if @_ and $_[0] eq "-v";

    my $command_code = __PACKAGE__->can("COMMAND_$command")
        or _usage("invalid SUBCOMMAND");
    _ensure_user_email();    # fix this first!
    _self_check_version() unless $command eq 'selfupdate';
    $command_code->(@_);
}

=head1 NAME

git-project - interact with (mt) git project repos

=head1 SYNOPSIS

  git project [-v] SUBCOMMAND [PROJECT-NAME] [ITEM-SELECTOR]
  git project -h

=head1 DESCRIPTION

See Nate.  It was all his idea anyway.

=head1 OPTIONS

=over

=item -v

Enable verbose mode.  Many git commands are noisy, and verbose
mode lets you see that.

Note that there's no "quiet" mode yet.

=item -h

Display part of the embedded pod doc, then exit.

=item PROJECT-NAME

For a new repo (via either clone or start), designates an immediate
subdirectory into which the project repo will be created.

For an existing repo, this option can be omitted, as long the current
directory is somewhere within the repo.  If the current directory is
immediately above the repo, the name may be specified to indicate the
subdirectory.

Project names must be between 5 and 100 characters long, and be
composed only of letters, digits, underscores and dashes.

=item ITEM-SELECTOR

An item selector is one or more specifications,
each of which are either a wildcard, like C<--apps>,
or an individual item selection, like C<--apps accountcenter>.

For most commands, a wildcard means "operate on all current items of
this type in the project", and an absence of any item selector means
to operate on B<all> items of the project.

The C<start> and C<add> subcommands interpret the item selector
slightly differently.  The selected individual items must not already
be in the project (or there'd be no reason to add them), and the
wildcard selector invokes a "picker" to interactively select items of
that category that are not yet in the project.  If no item selector
is given, then no items are included, and no picker is invoked.

  --apps # wildcard for apps group
  --apps accountcenter # specific
  --apps foo,bar # more than one
  --apps foo bar # also works

=back

=head1 SUBCOMMANDS

=over

=item selfupdate

Updates git-project and git-project-subtree if needed.

=cut

sub COMMAND_selfupdate {
    my $latest = _get_latest_version();
    if ( $latest > $VERSION ) {
        print <<INTERPOLATED;
You have version $VERSION of git-project.
A newer version of git-project is available: $latest.
Upgrading now...
INTERPOLATED
        my $installer = run_remote_text(qw(install));
        system $installer;
    }
    else {
        print <<INTERPOLATED;
You already have the latest version of git-project ($latest).
INTERPOLATED
    }
}

sub _get_latest_version {
    my $latest_text = run_remote_text(qw(install --version));
    if ( my ($latest) = $latest_text =~ m{\A\s*(\d+)\s*\z} ) {
        return $latest;
    }
    else {
        die "unknown response from server: $latest_text\n";
    }
}

sub _self_check_version {
    if ( my @stat = stat $VERSION_CHECK_DEFER ) {
        if ( time <= $stat[9] + $VERSION_CHECK_DEFER_INTERVAL ) {
            return;
        }
    }
    my $latest = _get_latest_version();
    if ( $latest > $VERSION ) {
        die <<"INTERPOLATED";
You have version $VERSION of git-project.
A newer version of git-project is available: $latest.

  You *MUST* update before continuing.

Try 'git project selfupdate' to update, or the commands for
your packaging system if git-project was installed that way.
INTERPOLATED
    }
    {
        open my $fh, ">", $VERSION_CHECK_DEFER
            or die "Cannot create $VERSION_CHECK_DEFER: $!";
        utime( time, time, $fh );
    }
}

=item version

Print out the version of git-project.

=cut

sub COMMAND_version {
    print "$VERSION\n";
}

=item list

Get a list of projects.

=cut

sub COMMAND_list {
    print Dump run_remote(qw(project-list));
}

=item name

Print the name of the current project.

=cut

sub COMMAND_name {
    my $repo = _get_repo_maybe_first_arg( \@_ );
    print $repo->{project_name}, "\n";
}

=item review

Print print the fishey/crucible url for the current project.

=cut

sub COMMAND_review {
    my $repo = _get_repo_maybe_first_arg( \@_ );
    my $name = $repo->{project_name};

    print "https://fish.mtsvc.net/changelog/projects-$repo->{project_name}/\n";
}

=item info [PROJECT-NAME]

Get a list of items.  If PROJECT-NAME is specified, get a list of
items associated with a particular project.  If PROJECT-NAME is
absent, get a list of B<all> items.

=cut

sub COMMAND_info {
    my $project = shift || "master";
    print Dump run_remote( qw(project-list --project), $project );
}

=item find ITEM

Find all projects using a given item.

=cut

sub COMMAND_find {
    print Dump run_remote( qw(project-find), @_ );
}

=item pick ITEM-SELECTOR

Internal. Runs the item picker with the given item selector,
and returns the result.

=cut

## there won't be a real pick... just using this to test the picker
sub COMMAND_pick {
    print Dump run_remote_interactive( qw(project-pick), @_ );
}

=item clone PROJECT-NAME

Clones existing project into a subdirectory.

=cut

sub COMMAND_clone {
    if ( my $repo = _repo('.') ) {
        _usage( "will not create new repo inside ", $repo->wc_path );
    }
    my $project = shift;
    $project =~ $PROJECT_NAME
        or _usage("bad project name: $project");
    -d $project
        and _usage("Won't overwrite existing directory with $project");
    _existing_repo("projects/$project")
        or _usage("Project $project does not exist... use 'git project start $project' instead");
    _clone_it_down($project);
}

=item start PROJECT-NAME [ITEM-SELECTOR]

Starts a new project (name must not already be in use).
Creates a repo in a subdirectory, and adds the selected items, if any.

=cut

sub COMMAND_start {
    if ( my $repo = _repo('.') ) {
        _usage( "will not create new repo inside ", $repo->wc_path );
    }
    my $project = shift;
    $project =~ $PROJECT_NAME
        or _usage("bad project name: $project");
    -d $project
        and _usage("Won't overwrite existing directory with $project");
    _existing_repo("projects/$project")
        and _usage("Project $project already exists... use 'git project clone $project' instead");
    my $repo = _clone_it_down($project);
    ## now add the items...
    _add_to_repo( $repo, @_ );
}

=item add [PROJECT-NAME] [ITEM-SELECTOR]

Adds additional items (explictly, or using the picker) to the project.

=cut

sub COMMAND_add {
    my $repo = _get_repo_maybe_first_arg( \@_ );
    _add_to_repo( $repo, @_ );
}

=item pull [PROJECT-NAME] [ITEM-SELECTOR]

Refreshes the selected items (or all items if no selector) from
"trunk" by merging in any additional commits since the previous pull
or add.

=cut

sub COMMAND_pull {
    my $repo = _get_repo_maybe_first_arg( \@_ );

    my $project = $repo->{project_name};
    print "pulling project $project in ", $repo->wc_path, "\n";
    _ensure_clean_repo($repo);
    _ensure_sync_remote($repo);

    for my $module ( _modules_for_repo( $repo, @_ ) ) {
        print "refreshing $module...\n";
        ## git project-subtree doesn't like not being noisy :(
        eval {
            $repo->command_noisy(
                qw(project-subtree pull),                  "--prefix=$module",
                "--message=sync to $project from $module", "${PREFIX}dev/$module",
                "master"
            );
            "ok";
        } and next;
        die <<"INTERPOLATED";
==============
git-project-subtree has failed.  Hopefully, the message above
will give you enough information to fix the problem.

Then re-run 'git project pull' as you did before.
INTERPOLATED
    }
    $repo->$maybe_noisy(qw(push origin master:master));
}

=item diff [PROJECT-NAME] [ITEM-SELECTOR]

Creates a "split" branch to examine changes locally and remotely since
the common ancestor, then calls "git diff" to show locally introduced changes.

If you want to do more than a simple diff, see C<git project split>.

=cut

sub COMMAND_diff {
    _diff_or_log( diff => @_ );
}

=item log [PROJECT-NAME] [ITEM-SELECTOR]

Creates a "split" branch to examine changes locally and remotely since
the common ancestor, then calls "git log" to show locally introduced changes.

If you want to do more than a simple log, see C<git project split>.

=cut

sub COMMAND_log {
    _diff_or_log( log => @_ );
}

sub _diff_or_log {
    my $command = shift;
    my $repo    = _get_repo_maybe_first_arg( \@_ );

    my $project = $repo->{project_name};
    print "diff project $project in ", $repo->wc_path, "\n";
    _ensure_clean_repo($repo);    # XXX: do we care?
    ## we don't care if remote is sync'ed, since this is just exploratory

    my @modules = _modules_for_repo( $repo, @_ );
    _split_modules( $repo, @modules );
    for my $module (@modules) {
        print "\n=== $command for $module:\n";
        $repo->command_noisy( $command, "upstream/$module...split/$module" );
        print "\n===\n";
    }
    _splitclean($repo);
}

=item split [PROJECT-NAME] [ITEM-SELECTOR]

Creates "split" and "upstream" branches for each requested item to
examine changes locally and remotely since the common ancestor.

Branches are named C<split/$item> and C<upstream/$item>.  As a
convenience, the split branches are also set to have the proper
corresponding upstream, accessible with a suffix of C<@{u}> on the
branch name.

Remove the branches with C<git project splitclean>.

=cut

sub COMMAND_split {
    my $repo = _get_repo_maybe_first_arg( \@_ );

    my $project = $repo->{project_name};
    print "splitting project $project in ", $repo->wc_path, "\n";
    _ensure_clean_repo($repo);    # XXX: do we care?
    ## we don't care if remote is sync'ed, since this is just exploratory

    _split_modules( $repo, _modules_for_repo( $repo, @_ ) );
}

sub _split_modules {
    my $repo = shift;

    for my $module (@_) {
        print "splitting $module...\n";
        $repo->$maybe_noisy( "fetch", "${PREFIX}dev/$module", "master" );
        $repo->$maybe_noisy( "branch", "-f", "upstream/$module", "FETCH_HEAD" );
        chomp( my $commit = $repo->command( qw(project-subtree split), "--prefix=$module" ) );
        $repo->$maybe_noisy( "branch", "-f",             "split/$module", $commit );
        $repo->$maybe_noisy( "branch", "--set-upstream", "split/$module", "upstream/$module" );
    }
}

=item splitclean [PROJECT-NAME]

Cleans the C<split/*> and C<upstream/*> branches made by C<split>.

=cut

sub COMMAND_splitclean {
    my $repo = _get_repo_maybe_first_arg( \@_ );

    my $project = $repo->{project_name};
    print "cleaning the splits for project $project in ", $repo->wc_path, "\n";
    _ensure_clean_repo($repo);    # XXX: do we care?
    ## we don't care if remote is sync'ed, since this is just exploratory

    _splitclean($repo);
}

sub _splitclean {
    my $repo = shift;

    if (my @refs = $repo->command(
            qw(for-each-ref --format %(refname:short) refs/heads/split/ refs/heads/upstream/)
        )
        )
    {
        $repo->command_noisy( qw(branch -D), @refs );
    }
}

=item status [PROJECT-NAME]

Verifies that the local working directory is clean and switched to the
C<master> branch, and that the local master is in sync with the remote
master.

=cut

sub COMMAND_status {
    my $repo = _get_repo_maybe_first_arg( \@_ );

    _ensure_clean_repo($repo);
    _ensure_sync_remote($repo);
    print "Everything is up to date for $repo->{project_name}\n";
}

=item push [PROJECT-NAME] [ITEM-SELECTOR]

B<DO NOT USE THIS COMMAND!> This command normally occurs as part of a
C<git project end>.  However, there may be times when you want to
commit a portion of your work to the trunk and yet still continue to
work on it.  If that's the case, read on.

Pushes any changes to the selected items (or all items) to "trunk".
This will fail if the changes have not incorporated the "trunk"; you
may need to pull first.

=cut

sub COMMAND_push {
    my $repo = _get_repo_maybe_first_arg( \@_ );

    my $project = $repo->{project_name};
    print "pushing project $project in ", $repo->wc_path, "\n";
    return unless _push_or_end_warning( push => @_ );
    _push_and_remove( $repo, 1, 0, @_ );
}

=item remove [PROJECT-NAME] [ITEM-SELECTOR]

Removes items from the project, abandoning any un-pushed changes.

=cut

sub COMMAND_remove {
    my $repo = _get_repo_maybe_first_arg( \@_ );

    my $project = $repo->{project_name};
    print "removing from project $project in ", $repo->wc_path, "\n";
    _push_and_remove( $repo, 0, 1, @_ );
}

=item end [PROJECT-NAME] [ITEM-SELECTOR]

Combines "push" and "remove", effectively transferring any changes for
the selected items from the project to trunk.

=cut

sub COMMAND_end {
    my $repo = _get_repo_maybe_first_arg( \@_ );

    my $project = $repo->{project_name};
    print "ending project $project in ", $repo->wc_path, "\n";
    return unless _push_or_end_warning( end => @_ );
    _push_and_remove( $repo, 1, 1, @_ );
}

sub _push_or_end_warning {
    my $push_or_end = shift;

    my $things = @_ ? "the selected items" : "this project";

    print "This command will merge $things into master,\n";

    if ( $push_or_end eq "push" ) {
        print <<"INTERPOLATED";
but *not* remove $things from the project.

 #####  ####### ####### ######
#     #    #    #     # #     #
#          #    #     # #     #
 #####     #    #     # ######
      #    #    #     # #
#     #    #    #     # #
 #####     #    ####### #

THIS COMMAND IS NOT NORMALLY USED.  You should be using 'git project end'
instead of 'git project push'!

Continue only if you understand *why* it is not normally used,
and still want to do something unusual.
INTERPOLATED

        print "Are you really sure you want to do this? (n/Y): ";
        my $result = ( <STDIN> !~ m{^(n.*)?$}i );
        if ($result) {
            print <<"INTERPOLATED";

   #    ######  #######    #     # ####### #     #
  # #   #     # #           #   #  #     # #     #
 #   #  #     # #            # #   #     # #     #
#     # ######  #####         #    #     # #     #
####### #   #   #             #    #     # #     #
#     # #    #  #             #    #     # #     #
#     # #     # #######       #    #######  #####

 #####  #     # ######  #######  #####
#     # #     # #     # #       #     #
#       #     # #     # #             #
 #####  #     # ######  #####      ###
      # #     # #   #   #          #
#     # #     # #    #  #
 #####   #####  #     # #######    #

INTERPOLATED
        }
        else {
            return 0;
        }
    }
    else {
        if (@_) {    # end items
            print "and remove them from the project.";
        }
        else {       # end project
            print "and effectively terminate the project.";
        }
    }
    print "\n";

    print <<"INTERPOLATED";
To see what will be merged, run the following commands:

  git project diff @_
  git project log @_

** Remember that it is your responsibility to deploy these changes ASAP! **

INTERPOLATED

    # default to no
    print "Do you want $push_or_end $things (n/Y): ";
    return <STDIN> !~ m{^(n.*)?$}i;
}

=back

=head1 SEE ALSO

L<The Confluence page on Platform 2.0 Code and Packaging|https://tools.mtsvc.net/confluence/display/ENG/Platform+2.0+-+Code+and+Packaging>

=cut

sub _clone_it_down {
    my $project = shift;

    if ( $PREFIX =~ m{\A/} ) {    # special case if we're running locally
        my $dir = "${PREFIX}projects/$project";
        unless ( -d $dir ) {
            Git::command_noisy( qw(init --bare --shared), $dir );
        }
    }
    Git::command_noisy( 'clone', "${PREFIX}projects/$project" );
    ## at this point, it might be an existing project, or a new project
    my $repo = _repo($project) or die "what happened to the repo?";
    if ( eval { $repo->command(qw(rev-parse --verify --quiet HEAD)) } ) {
        ## existing repo... no need for initial commit
        print "cloned existing repo...\n";
    }
    else {
        $repo->$maybe_noisy(qw(commit -n --allow-empty -m init));
        $repo->$maybe_noisy(qw(push origin -u master:master));
    }
    _update_hooks($repo);
    _create_custom_git_commit_message( $project, $repo );
    return $repo;
}

sub _create_custom_git_commit_message {
    my ( $project, $repo ) = @_;

    if ( $project =~ m{([A-Z]+-\d+)} ) {
        my $jira_id = $1;
        ## Stuff project name into git commit messages.
        my $gitmessage_file = $repo->repo_path . '/.gitmessage.txt';
        open my $fh, ">", $gitmessage_file or die "Cannot create $gitmessage_file: $!";
        print $fh "\n\n$jira_id\n";
        close $fh or die "Failed writing $gitmessage_file: $!";

        $repo->command( qw(config), 'commit.template', '.git/.gitmessage.txt' );
    }
}

sub _update_hooks {
    my $repo = shift;

    my $hooks_dir = $repo->repo_path . "/hooks";
    {
        my $pre_commit_path = "$hooks_dir/pre-commit";
        open my $fh, ">", $pre_commit_path
            or die "Cannot create $pre_commit_path: $!";
        print $fh <<'END_OF_PRE_COMMIT_HOOK';
#!/usr/bin/perl
use strict;

my $VERBOSE = 0;

my $WIDTH          = 100;
my $TIDY_COMMAND   = "perltidy -pbp -l=$WIDTH -nst -b -nse -nasc";
my $CRITIC_COMMAND = "perlcritic --quiet <";

# my $IGNORE_TYPE = join "|", qw(
#     apps
#     apps-vendor
#     perl-libs-vendor
#     puppet-mods-base
#     puppet-mods-deploy
#     puppet-mods-site
#     ruby-libs-vendor
#     python-vendor
# );
# $IGNORE_TYPE = qr{($IGNORE_TYPE)};

## https://svn.mediatemple.net/puppet_mods/trunk/site/svn/files/pre-commit.d/check_perltidy

my $CHECK_TYPE = join "|", qw(
    perl-libs/MT
    perl-libs/CoreDB
    perl-libs/Ringzler
);
$CHECK_TYPE = qr{($CHECK_TYPE)};

## if this fails...
`git rev-parse --verify --quiet HEAD`;
## use magical "git hash-object -t tree /dev/null" head, otherwise HEAD
my $against = $? ? "4b825dc642cb6eb9a060e54bf8d69288fbee4904" : "HEAD";

my @rawdiff = split /\0/, `git diff -z --raw --abbrev=40 --cached $against`;
exit 0 unless @rawdiff;

require File::Temp;
my $dir = File::Temp::tempdir( CLEANUP => 1 );

my $good = 1;

FILE: while (@rawdiff) {
    my ( $oldmode, $newmode, $oldrev, $newrev, $action ) = split ' ', shift @rawdiff;
    my $oldname = shift @rawdiff;
    my $newname = $oldname;
    $newname = shift @rawdiff if $action =~ /[CR]/;
    print "$action $oldname $oldrev->$newrev ($newname)\n" if $VERBOSE;
    if ( $newmode eq "120000" ) {
        print "skipping symlink\n" if $VERBOSE;
        next FILE;
    }
    if ( $action =~ /[ACMR]/ ) {
        ## todo: have some sort of flag for "don't check these"
        my $broken = "";

        my ( $fh, $filename ) = File::Temp::tempfile( DIR => $dir );
        system "git show $newrev >$filename";

    EVERY_FILE: {
            ## all files: check for conflict markers
            seek $fh, 0, 0 or die "Cannot seek on $filename: $!";
        LINE: while (<$fh>) {
                if (m{^(<<<<<<<|=======|>>>>>>>|####### Ancestor)}) {
                    $broken .= "found merge conflict marker: $_";
                }
            }
        }

    PERL_FILE: {

            ## perl files, check for perlishness

            if ( not $newname =~ m{^$CHECK_TYPE/} ) {
                print "skipping protected item_type in subtree repo\n" if $VERBOSE;
                next;
            }
            ## check the extension first
            my $is_perl = $newname =~ m{\.(pl|PL|pm|t)\z};
            unless ($is_perl) {    # check the contents
                seek $fh, 0, 0 or die "Cannot seek on $filename: $!";
                $is_perl = <$fh> =~ m{\A#!.*perl};
            }
            unless ($is_perl) {
                print "skipped... not Perl\n" if $VERBOSE;
                last PERL_FILE;
            }
            if ( $filename =~ m{\.in$} ) {
                print "skipped... won't break configure inputs\n" if $VERBOSE;
                last PERL_FILE;
            }

            ## first, perlcritic:
            if (0) {
                my $err    = `$CRITIC_COMMAND $filename 2>&1`;
                my $status = $?;
                $broken .= "perlcritic exit status: $status\n" if $status;
                $broken .= "perlcritic errors:\n$err"          if $err;
            }

            ## second, perltidy:
            {
                my $err    = `$TIDY_COMMAND $filename 2>&1`;
                my $status = $?;
                $broken .= "perltidy exit status: $status\n" if $status;
                $broken .= "perltidy errors:\n$err"          if $err;
                my $diff = `diff -c $filename.bak $filename`;
                if ($diff) {
                    $broken .= "perltidy diff:\n$diff";
                    $broken .= "(generated from $TIDY_COMMAND $newname)\n";
                }
            }
        }

        ## let the user know the bad news:
        next FILE unless $broken;
        print "$newname: $_\n" for split /\n/, $broken;
        $good = 0;
    }
}

die "commit aborted\n" unless $good;
END_OF_PRE_COMMIT_HOOK
        chmod 0755, $pre_commit_path;
    }
    {
        my $commit_msg_path = "$hooks_dir/commit-msg";
        open my $fh, ">", $commit_msg_path
            or die "Cannot create $commit_msg_path: $!";
        print $fh <<'END_OF_COMMIT_MSG_HOOK';
#!/usr/bin/perl
use strict;

my $VERBOSE = 0;

my $file = shift;
defined( my $pid = open my $fh, "-|" ) or die "Cannot fork: $!";
unless ($pid) {    # child does:
    open STDIN, "<", $file or die "Cannot open $file: $!";
    exec qw(git stripspace -s);
    die "Cannot find git stripspace: $!";
}
my $first_ok = my $blank_line_ok = my $body_ok = 1;
CHECK: {
    unless ( defined( $_ = <$fh> ) ) {
        $first_ok = 0;
        warn "Missing commit message\n";
        last CHECK;
    }
    if ( length $_ > 61 ) {    # 60 + newline
        $first_ok = 0;
        warn "First line of commit exceeds recommended 60 characters\n";
    }
    unless (/\S/) {
        $first_ok = 0;
        warn "First line of commit should not blank\n";
    }
    defined( $_ = <$fh> ) or last CHECK;
    if (/\S/) {
        $blank_line_ok = 0;
        warn "Second line of commit should be blank\n";
    }
    while ( defined( $_ = <$fh> ) ) {
        if ( length $_ > 100 ) {
            $body_ok = 0;
            warn "Body line of commit exceeds recommended 100 characters\n";
            last CHECK;
        }
    }
}
my $good = $first_ok && $blank_line_ok && $body_ok;
die "Child had trouble: $! (exit $?)" unless close($fh) and not $?;
die "commit aborted\n" unless $good;
END_OF_COMMIT_MSG_HOOK
        chmod 0755, $commit_msg_path;
    }
    ## record the version number of these hooks
    $repo->command( qw(config), $CONFIGNAME, $VERSION );
}

sub _push_and_remove {
    my $repo   = shift;
    my $push   = shift;
    my $remove = shift;
    _ensure_clean_repo($repo);
    _ensure_sync_remote($repo);

    my @modules = _modules_for_repo( $repo, @_ );
    if ($push) {    # make sure we can push everywhere
        _split_modules( $repo, @modules );
        my @bad;
        for my $module (@modules) {
            my ( $ahead, $behind ) = _ahead_or_behind( $repo, "split/$module", "upstream/$module" );
            if ($behind) {
                push @bad, $module;
            }
        }
        _splitclean($repo);
        if (@bad) {
            @bad = sort @bad;
            my @cmd = map { m{(.*?)/(.*)} ? "--$1 $2" : die } @bad;
            print <<"INTERPOLATED";
These items have upstream commits that you have not yet incorporated:

  @bad

You should pull each item locally and re-test before attempting
to push or end with:

  git project pull @cmd
INTERPOLATED
            return;
        }
    }

    if ( $remove and not $push ) {    # make sure we aren't losing work
        _split_modules( $repo, @modules );
        my @bad;
        for my $module (@modules) {
            my ( $ahead, $behind ) = _ahead_or_behind( $repo, "split/$module", "upstream/$module" );
            if ($ahead) {
                push @bad, $module;
            }
        }
        _splitclean($repo);
        if (@bad) {
            @bad = sort @bad;
            my @cmd = map { m{(.*?)/(.*)} ? "--$1 $2" : die } @bad;
            print <<"INTERPOLATED";
These items have local commits that you have not yet pushed upstream:

  @bad

To see what has not yet been pushed, run the following commands:

  git project diff @cmd
  git project log @cmd

If you continue, you will LOSE WORK.  Think very carefully about this.
INTERPOLATED
            print "Do you wish to continue (Y/n): ";
            return unless <STDIN> =~ m{^(y.*)?$}i;
        }
    }

    for my $module (@modules) {
        if ($push) {
            print "pushing $module...\n";
            ## this will fail if it's not a fast forward
            ## TODO: catch that, and give a more sane error message
            $repo->command_noisy(
                qw(project-subtree push), "--prefix=$module",
                "--rejoin",               "${PREFIX}dev/$module",
                "master"
            );
        }
        if ($remove) {
            print "removing $module...\n";
            $repo->command_noisy( qw(rm -rf), $module );
            $repo->command( qw(commit -n -m), "remove $module" );
            ## keep project repo in sync
            $repo->command_noisy(qw(push origin master:master));
        }
    }
}

sub _modules_for_repo {
    my $repo = shift;

    my $match_this = qr{^($MATCH_TYPE/[^/]+)\z};
    if (@_) {    # restricted selection
        my ( $items, $groups ) = _parse_like_picker(@_);
        my @any_of_these;
        for my $group ( sort keys %$items ) {
            for my $item ( @{ $items->{$group} } ) {
                push @any_of_these, "$group/\Q$item\E";
            }
        }
        for my $group (@$groups) {
            push @any_of_these, "$group/[^/]+";
        }
        my $choose = join "|", @any_of_these;
        $match_this = qr{^($choose)\z};
    }

    ## cribbed from Project::Git

    my %modules;
    my @dirs = split /\0/, $repo->command(qw(ls-tree -z --name-only -d -r master));
    for my $dir (@dirs) {
        next unless my ($module) = $dir =~ $match_this;
        $modules{$module} = 1;
    }
    return sort keys %modules;
}

sub _add_to_repo {
    my $repo    = shift;
    my $project = $repo->{project_name};
    print "adding to project $project in ", $repo->wc_path, "\n";
    _ensure_clean_repo($repo);
    _ensure_sync_remote($repo);
    my $result = run_remote_interactive( qw(project-pick), @_, qw(--exclude), $project );
    my $items = $result->{items};    # HoA
    my @modules;
    my @bad;

    for my $item_group ( sort keys %$items ) {

        for my $item ( sort @{ $items->{$item_group} } ) {
            my $module = "$item_group/$item";
            if ( _existing_repo("dev/$module") ) {
                push @modules, $module;
            }
            else {
                push @bad, $module;
            }
        }
    }
    if (@bad) {
        @bad = sort @bad;
        die <<"INTERPOLATED";
The following items were not found:

    @bad

You cannot add them to a project until they have first been created,
using git clone and git push to ensure they have a master branch.
INTERPOLATED
    }

    my $base_branch = $ENV{GIT_PROJECT_BASE_BRANCH} || 'master';

    for my $module ( sort @modules ) {
        print "adding $module...\n";
        my @cmd
            = ( qw(project-subtree add), "--prefix=$module", "${PREFIX}dev/$module", $base_branch );
        $repo->command_noisy(@cmd);
        $repo->$maybe_noisy(qw(push origin master:master));
    }
}

sub run_remote_text {
    return _run_remote_raw( 0, 1, @_ );
}

sub run_remote {
    return _run_remote( 0, 0, @_ );
}

sub run_remote_interactive {
    return _run_remote( 1, 0, @_ );
}

sub _run_remote {
    my $output = _run_remote_raw(@_);

    my $result;
    my @possibles = $output =~ m{[\[\{][\x20-\x7f]*[\}\]]}g;
    for ( reverse @possibles ) {
        last if $result = eval { from_json($_) };
    }
    die "couldn't find any good JSON in:\n$output\n" unless $result;
    return $result;
}

sub _run_remote_raw {
    my $interactive  = shift;
    my $merge_stderr = shift;

    local $| = 1;
    defined( my $child = open my $fh, "-|" ) or die "Cannot fork: $!";
    unless ($child) {
        open STDERR, ">&STDOUT" if $merge_stderr;
        my @prefix = qw(ssh -q);
        push @prefix, "-t" if $interactive;
        push @prefix, $HOST;
        exec @prefix, @_;
        die "Cannot exec @prefix @_: $!";
    }
    my $output = "";
    my $status;
    while ( $status = sysread $fh, my $buf, 1024 ) {
        print $buf if $interactive;
        $output .= $buf;
    }
    die "sysread: $!" unless defined $status;
    close $fh;
    return $output;
}

sub _existing_repo {
    my $repo_name = shift;
    my $output = run_remote_text( "info", $repo_name );
    $output =~ tr/\r//d;
    return 1 if $output =~ m{\s\Q$repo_name\E\n};
}

sub _repo {
    my $directory = shift || ".";
    my $repo = eval { Git->repository($directory) } || return;
    my $repo_project_name = $repo->config('remote.origin.url')
        or die "no remote.origin.url?";
    $repo_project_name =~ s{\A.*?[:/]projects/}{}
        or die "$repo_project_name doesn't look like a project repo remote";
    $repo->{project_name} = $repo_project_name;    # hope this doesn't clash
    $repo->wc_chdir('');                           # always relative to top dir
    return $repo;
}

sub _get_repo_maybe_first_arg {
    my $repo         = _get_repo_maybe_first_arg_helper(@_);
    my $repo_version = $repo->config($CONFIGNAME);
    ## all up to date?
    return $repo
        if $repo_version and $repo_version >= $VERSION_HOOKS_COMPAT;
    ## nope... time to refresh the hooks
    ## this might need to be complicated if it isn't just a simple re-run
    $repo_version ||= 0;
    print "[Upgrading your hooks from version $repo_version to $VERSION...]\n";
    _update_hooks($repo);
    return $repo;
}

sub _get_repo_maybe_first_arg_helper {
    my $argref = shift;
    if ( @$argref and $argref->[0] =~ $PROJECT_NAME ) {
        my $project = shift @{$argref};
        my $repo = -d $project ? _repo($project) : _repo('.');
        unless ($repo) {
            die <<"INTERPOLATED";
Where is project $project?

You must use this command either:

(a) from within a repo that is already associated with
    project $project, or
(b) from the parent directory of that repo,
    in which case the subdirectory must be named either
    $project or $project.git.
INTERPOLATED
        }
        ## ensure repo name match
        my $repo_project_name = $repo->{project_name};
        die "Repo project name is $repo_project_name, not $project\n"
            unless $repo_project_name eq $project;
        return $repo;
    }
    return _repo('.') || die "where is the project?\n";
}

## cribbed from project-pick
sub _parse_like_picker {
    local @ARGV = @_;

    my %groups;
    GetOptions( map { $_ . ':s@{,}' => \$groups{$_} } @ITEM_GROUPS )
        or die "Cannot parse options: @_";
    @ARGV and _usage("Extra options: @ARGV");
    my %items;

    my @picker_groups;
    for my $group ( keys %groups ) {
        next unless defined( my $value = $groups{$group} );    # not selected
        my @values = grep /\S/, map { split /,/ } @$value;     # legacy *and* new
        if (@values) {
            $items{$group} = [ sort @values ];                 # explicit - no picker
        }
        else {
            push @picker_groups, $group;
        }
    }
    return \%items, \@picker_groups;
}

sub _ensure_user_email {
    ## prevent dev box names from ending up in commit messages
    chomp( my $user_email = `git config --get user.email` );
    unless ($?) {
        return unless $user_email =~ m{\b(mtsvc|mediatemple)\b};
        return if $user_email =~ m{\@mediatemple\.net\z};
    }
    die join( "\n",
        'Please set your username and user email with:',
        '  git config --global user.email YOURUSER@mediatemple.net',
        '  git config --global user.name "FIRST LAST"',
        '' );
}

sub _ensure_clean_repo {
    my $repo = shift;
    if ( length $repo->command(qw(status --porcelain -z)) ) {
        die "The repo is dirty... please resolve the following issues:\n"
            . $repo->command(qw(status));
    }
    unless ( eval { $repo->command(qw(symbolic-ref -q HEAD)) eq "refs/heads/master\n"; } ) {
        die "Please switch to the master branch before proceeding.\n";
    }
}

sub _ensure_sync_remote {
    my $repo = shift;
    $repo->command(qw(fetch origin));    # update remotes
    my ( $ahead, $behind ) = _ahead_or_behind( $repo, "master", "remotes/origin/master" );
    return unless $ahead or $behind;
    if ($behind) {
        if ($ahead) {
            die
                "Your repo is ahead by $ahead local commit(s), and is behind by $behind remote commit(s).\n",
                "Please 'git pull origin' and test before proceeding,\n",
                "then 'git push origin' to be fully in sync.\n";
        }
        die "Your repo is behind by $behind remote commit(s).\n",
            "Please 'git pull origin' and test before proceeding.\n",
            "(This should be a fast-forward merge.)\n";
    }
    if ($ahead) {
        die "Your repo is ahead by $ahead local commit(s).\n",
            "Please 'git push origin' to be fully in sync.\n";
    }
}

sub _usage {
    if ( my $message = join "", @_ ) {    # invoked from something broken
        pod2usage(
            -verbose => 0,
            -input   => __FILE__,
            -message => $message,
        );

    }
    else {                                # invoked from help
        pod2usage(
            -verbose  => 99,
            -sections => 'SYNOPSIS|OPTIONS|SUBCOMMANDS',
            -input    => __FILE__,
        );
    }
}

sub _ahead_or_behind {
    my $repo = shift;
    my $us   = shift;
    my $them = shift;

    my $ahead = my $behind = 0;
    for ( $repo->command( qw(rev-list --left-right), "$us...$them" ) ) {
        $ahead++,  next if /^</;
        $behind++, next if /^>/;
        die "what is this from rev-list: $_";
    }
    return ( $ahead, $behind );
}

BEGIN {

    package YAML::Tiny;    # but only the needed parts :)

    use Scalar::Util qw(refaddr);

    # Printed form of the unprintable characters in the lowest range
    # of ASCII characters, listed by ASCII ordinal position.
    my @UNPRINTABLE = qw(
        z    x01  x02  x03  x04  x05  x06  a
        x08  t    n    v    f    r    x0e  x0f
        x10  x11  x12  x13  x14  x15  x16  x17
        x18  x19  x1a  e    x1c  x1d  x1e  x1f
    );

    # Printable characters for escapes
    my %UNESCAPES = (
        z    => "\x00",
        a    => "\x07",
        t    => "\x09",
        n    => "\x0a",
        v    => "\x0b",
        f    => "\x0c",
        r    => "\x0d",
        e    => "\x1b",
        '\\' => '\\',
    );

    # Special magic boolean words
    my %QUOTE = map { $_ => 1 } qw{
        null Null NULL
        y Y yes Yes YES n N no No NO
        true True TRUE false False FALSE
        on On ON off Off OFF
    };

    # Create an empty YAML::Tiny object
    sub new {
        my $class = shift;
        bless [@_], $class;
    }

    # Save an object to a string
    sub write_string {
        my $self = shift;
        return '' unless @$self;

        # Iterate over the documents
        my $indent = 0;
        my @lines  = ();
        foreach my $cursor (@$self) {
            push @lines, '---';

            # An empty document
            if ( !defined $cursor ) {

                # Do nothing

                # A scalar document
            }
            elsif ( !ref $cursor ) {
                $lines[-1] .= ' ' . $self->_write_scalar( $cursor, $indent );

                # A list at the root
            }
            elsif ( ref $cursor eq 'ARRAY' ) {
                unless (@$cursor) {
                    $lines[-1] .= ' []';
                    next;
                }
                push @lines, $self->_write_array( $cursor, $indent, {} );

                # A hash at the root
            }
            elsif ( ref $cursor eq 'HASH' ) {
                unless (%$cursor) {
                    $lines[-1] .= ' {}';
                    next;
                }
                push @lines, $self->_write_hash( $cursor, $indent, {} );

            }
            else {
                Carp::croak( "Cannot serialize " . ref($cursor) );
            }
        }

        join '', map {"$_\n"} @lines;
    }

    sub _write_scalar {
        my $string = $_[1];
        return '~'  unless defined $string;
        return "''" unless length $string;
        if ( $string =~ /[\x00-\x08\x0b-\x0d\x0e-\x1f\"\'\n]/ ) {
            $string =~ s/\\/\\\\/g;
            $string =~ s/"/\\"/g;
            $string =~ s/\n/\\n/g;
            $string =~ s/([\x00-\x1f])/\\$UNPRINTABLE[ord($1)]/g;
            return qq|"$string"|;
        }
        if ( $string =~ /(?:^\W|\s|:\z)/ or $QUOTE{$string} ) {
            return "'$string'";
        }
        return $string;
    }

    sub _write_array {
        my ( $self, $array, $indent, $seen ) = @_;
        if ( $seen->{ refaddr($array) }++ ) {
            die "YAML::Tiny does not support circular references";
        }
        my @lines = ();
        foreach my $el (@$array) {
            my $line = ( '  ' x $indent ) . '-';
            my $type = ref $el;
            if ( !$type ) {
                $line .= ' ' . $self->_write_scalar( $el, $indent + 1 );
                push @lines, $line;

            }
            elsif ( $type eq 'ARRAY' ) {
                if (@$el) {
                    push @lines, $line;
                    push @lines, $self->_write_array( $el, $indent + 1, $seen );
                }
                else {
                    $line .= ' []';
                    push @lines, $line;
                }

            }
            elsif ( $type eq 'HASH' ) {
                if ( keys %$el ) {
                    push @lines, $line;
                    push @lines, $self->_write_hash( $el, $indent + 1, $seen );
                }
                else {
                    $line .= ' {}';
                    push @lines, $line;
                }

            }
            else {
                die "YAML::Tiny does not support $type references";
            }
        }

        @lines;
    }

    sub _write_hash {
        my ( $self, $hash, $indent, $seen ) = @_;
        if ( $seen->{ refaddr($hash) }++ ) {
            die "YAML::Tiny does not support circular references";
        }
        my @lines = ();
        foreach my $name ( sort keys %$hash ) {
            my $el   = $hash->{$name};
            my $line = ( '  ' x $indent ) . "$name:";
            my $type = ref $el;
            if ( !$type ) {
                $line .= ' ' . $self->_write_scalar( $el, $indent + 1 );
                push @lines, $line;

            }
            elsif ( $type eq 'ARRAY' ) {
                if (@$el) {
                    push @lines, $line;
                    push @lines, $self->_write_array( $el, $indent + 1, $seen );
                }
                else {
                    $line .= ' []';
                    push @lines, $line;
                }

            }
            elsif ( $type eq 'HASH' ) {
                if ( keys %$el ) {
                    push @lines, $line;
                    push @lines, $self->_write_hash( $el, $indent + 1, $seen );
                }
                else {
                    $line .= ' {}';
                    push @lines, $line;
                }

            }
            else {
                die "YAML::Tiny does not support $type references";
            }
        }

        @lines;
    }

    # Set error
    sub _error {
        $YAML::Tiny::errstr = $_[1];
        undef;
    }

    # Retrieve error
    sub errstr {
        $YAML::Tiny::errstr;
    }

}

BEGIN {
    my $FROM_JSON = qr{

    (?&VALUE) (?{ $_ = $^R->[1] })

    (?(DEFINE)

    (?<OBJECT>
      (?{ [$^R, {}] })
      \{
	(?: (?&KV) # [[$^R, {}], $k, $v]
	  (?{ # warn Dumper { obj1 => $^R };
	     [$^R->[0][0], {$^R->[1] => $^R->[2]}] })
	  (?: , (?&KV) # [[$^R, {...}], $k, $v]
	    (?{ # warn Dumper { obj2 => $^R };
	       [$^R->[0][0], {%{$^R->[0][1]}, $^R->[1] => $^R->[2]}] })
	  )*
	)?
      \}
    )

    (?<KV>
      (?&STRING) # [$^R, "string"]
      : (?&VALUE) # [[$^R, "string"], $value]
      (?{ # warn Dumper { kv => $^R };
	 [$^R->[0][0], $^R->[0][1], $^R->[1]] })
    )

    (?<ARRAY>
      (?{ [$^R, []] })
      \[
	(?: (?&VALUE) (?{ [$^R->[0][0], [$^R->[1]]] })
	  (?: , (?&VALUE) (?{ # warn Dumper { atwo => $^R };
			     [$^R->[0][0], [@{$^R->[0][1]}, $^R->[1]]] })
	  )*
	)?
      \]
    )

    (?<VALUE>
      \s*
      (
	  (?&STRING)
	|
	  (?&NUMBER)
	|
	  (?&OBJECT)
	|
	  (?&ARRAY)
	|
	true (?{ [$^R, 1] })
      |
	false (?{ [$^R, 0] })
      |
	null (?{ [$^R, undef] })
      )
      \s*
    )

    (?<STRING>
      (
	"
	(?:
	  [^\\"]+
	|
	  \\ ["\\/bfnrt]
    #    |
    #      \\ u [0-9a-fA-f]{4}
	)*
	"
      )

      (?{ [$^R, eval $^N] })
    )

    (?<NUMBER>
      (
	-?
	(?: 0 | [1-9]\d* )
	(?: \. \d+ )?
	(?: [eE] [-+]? \d+ )?
      )

      (?{ [$^R, eval $^N] })
    )

    ) }xms;

    sub from_json {
        local $_ = shift;
        local $^R;
        eval { m{\A$FROM_JSON\z}; } and return $_;
        die $@ if $@;
        return undef;
    }
}
